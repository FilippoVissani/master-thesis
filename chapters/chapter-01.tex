%! Author = Filippo Vissani
%! Date = 08/02/24
% !TeX root = ../thesis-main.tex

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Developing artificial self-organizing systems with collective intelligence poses a significant research challenge that spans multiple disciplines in science and engineering. A central problem involves guiding the emergence of self-organizing behavior among a group of agents or devices, a task often referred to as "guided self-organization" or "controlled self-organization." This challenge revolves around defining the control program that each agent must execute. Solutions to this problem can be approached through automated methods such as multi-agent reinforcement learning or manual methods involving the definition of control rules and designs. Hybrid approaches combining both learning and manual intervention are also viable.

This thesis focuses on leveraging programming languages for self-organizing systems. Here, developers craft the self-organizing control program using a macroprogramming language, which aims to express the system's macro-level behavior. This language may be general-purpose or domain-specific, tailored to specific applications such as robotic swarms or wireless sensor networks. The overarching objective is to design a programming language that is expressive, practical, and declarative. This language should enable programmers to abstract away operational details, allowing the underlying middleware platform to handle them automatically.

Existing languages often use a loop-based execution model, where devices repeatedly evaluate their context and control the program cyclically or periodically. While this approach is simple, it lacks flexibility in scheduling and managing subtasks, especially in response to contextual changes. The primary objective of this thesis is to demonstrate the feasibility of implementing Reactive Aggregate Programming in Kotlin and to analyze the ergonomics of the proposed language in comparison to the proactive model. Specifically, we aim to assess the suitability of Kotlin for developing self-organizing systems using a reactive programming approach.

\paragraph{Thesis structure}

The structure of this thesis is designed to provide a comprehensive exploration of the topics at hand, starting with an in-depth Background section (\Cref{chap:background}). Here, we delve into Functional Programming, Reactive Programming, and Aggregate Computing, elucidating their core concepts and implementations in Kotlin, which serves as the foundation for the subsequent analyses. Moving forward, the Analysis section (\Cref{chap:analysis}) critically evaluates the current state of the art, examining notable frameworks such as Protelis, ScaFi, FCPP, Collektive, and FRASP. Building upon this analysis, we proceed to detail the design of FRASP and Collektive, including architectural frameworks and alignment processing strategies. The Integration section further investigates the seamless integration of FRASP into Collektive, addressing challenges, assessing feasibility, and proposing solutions. \Cref{chap:design}, Design, delineates the architectural and detailed designs of the proposed models, setting the stage for their Implementation (\Cref{chap:implementation}), where we describe the practical realization of these models, divided into sections for the purely reactive model and the incorporation of reactive messages and sensors. Subsequently, the Validation section (\Cref{chap:evaluation}) examines the testing procedures and evaluates the ergonomic aspects of the proposed models. Finally, the Conclusion section (\Cref{chap:conclusion}) synthesizes our findings, encapsulating the contributions of this thesis and suggesting avenues for future research in this domain.
