%! Author = Filippo Vissani
%! Date = 08/02/24
% !TeX root = ../thesis-main.tex

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Developing \textit{artificial self-organizing systems} with \textit{collective intelligence} poses a significant research challenge that spans multiple disciplines in science and engineering~\cite{Parunak2015, Gershenson2007, Singh2013, DeNicola2020}. A central problem involves guiding the \textit{self-organizing behavior among a group of agents or devices}, a task often referred to as "guided self-organization"~\cite{Prokopenko2007} or "controlled self-organization"~\cite{Schmeck2010}. This challenge revolves around defining the control program that each agent must execute~\cite{Martius2011}. Solutions to this problem can be approached through automatic approaches such as multi-agent reinforcement learning~\cite{Zhang2021} or manual approaches~\cite{Martius2011} involving the definition of control rules or designs in terms of patterns
involving, e.g., information flows and control loops~\cite{DeWolf2007}.

This thesis focuses on leveraging programming languages for self-organizing systems. Here, developers craft the self-organizing control program using a \textit{macroprogramming language}~\cite{Casadei2023_2, Jnior2022}, which aims to express the system's macro-level behavior. This language may be general-purpose or domain-specific, tailored to specific applications such as robotic swarms~\cite{Brambilla2013} or wireless sensor networks~\cite{Mottola2011}. The overarching objective is to design a programming language that is expressive, practical, and declarative. This language should enable programmers to abstract away operational details, allowing the underlying platform to handle them automatically~\cite{Noor2019, Casadei2020_2}.

Existing languages often use a \textit{round-based} execution model, where devices repeatedly evaluate their context program cyclically or periodically. While this approach is simple, it lacks flexibility in scheduling and managing subtasks, especially in response to contextual changes. The primary objective of this thesis is to demonstrate the feasibility of implementing reactive aggregate programming in Kotlin and to analyze the ergonomics of the proposed language in comparison to the proactive model, taking inspiration from the FRASP model~\cite{Casadei2023}. Specifically, we aim to assess the suitability of Kotlin for developing self-organizing systems using a reactive programming approach.

\paragraph{Thesis structure}

The structure of this thesis is designed to provide a comprehensive exploration of the topics, starting with an in-depth Background section (\Cref{chap:background}). Here, we delve into functional programming, reactive programming, and aggregate computing, elucidating their core concepts and implementations in Kotlin, which serves as the foundation for the subsequent analyses. Moving forward, the Analysis section (\Cref{chap:analysis}) evaluates the current state of the art, examining notable frameworks for aggregate computing, such as Protelis, ScaFi, FCPP, Collektive, and FRASP. Building upon this analysis, we proceed to detail the design of FRASP and Collektive. The Integration section further investigates the integration of FRASP into Collektive, addressing challenges, assessing feasibility, and proposing solutions. \Cref{chap:design}, Design, delineates the architectural and detailed designs of the proposed models, setting the stage for their Implementation (\Cref{chap:implementation}), where we describe the practical realization of these models, divided into sections for the purely reactive model and the model with reactive messages and sensors. Subsequently, the Validation section (\Cref{chap:evaluation}) examines the testing procedures and evaluates the ergonomic aspects of the proposed models. Finally, the Conclusion section (\Cref{chap:conclusion}) synthesizes our findings, encapsulating the contributions of this thesis and suggesting avenues for future research in this domain.
