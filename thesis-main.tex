\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{caption}
\usepackage{subcaption}

\school{\unibo}
\programme{MSc in Engineering and Computer Science}
\title{Feasibility of Reactive Aggregate Programming via Kotlin Flows}
\author{Filippo Vissani}
\date{\today}
\subject{Laboratory of Software Systems}
\supervisor{Prof. Danilo Pianini}
\cosupervisor{Dott. Gianluca Aguzzi}
\session{IV}
\academicyear{2022-2023}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{jvm}[JVM]{Java Virtual Machine}
\acrodef{cas}[CAS]{Collective Adaptive Systems}
\acrodef{fc}[FC]{Field Calculus}
\acrodef{dsl}[DSL]{Domain Specific Language}
\acrodef{frasp}[FRASP]{Functional Reactive Approach to Self-organisation Programming}

\mainlinespacing{1.241}

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
    The field of engineering self-organizing systems, encompassing realms such as robot swarms, collectives of wearables, and distributed infrastructures, has witnessed extensive exploration through diverse methodologies. These approaches range from deriving algorithms inspired by natural phenomena to leveraging design patterns, utilizing learning techniques to synthesize behavior based on emergent expectations, and exposing pivotal mechanisms and abstractions at the programming language level. Among these, a predominant focus has been on employing round-based execution models in state-of-the-art languages for self-organization. While such models offer simplicity in reasoning, they often exhibit limitations concerning flexibility and granular management of sub-activities. Drawing inspiration from the \ac{frasp} model implemented in Scala, this thesis aims to showcase the viability of reactive aggregate programming in Kotlin. Leveraging the Flow functional reactive library, we demonstrate a functional reactive implementation of aggregate programming, separating program logic from activity planning. The resulting framework maintains the expressive power of aggregate scheduling while enhancing scheduling controllability, flexibility in the sensing/actuation model, and execution efficiency.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

%----------------------------------------------------------------------------------------
\tableofcontents
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

\input{chapters/chapter-01}
\input{chapters/chapter-02}
\input{chapters/chapter-03}
\input{chapters/chapter-04}
\input{chapters/chapter-05}
\input{chapters/chapter-06}
\input{chapters/chapter-07}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

%\nocite{*} % comment this to only show the referenced entries from the .bib file

\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}