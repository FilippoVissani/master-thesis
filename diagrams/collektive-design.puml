@startuml
left to right direction

interface Aggregate<ID> << interface >> {
  + exchange(Initial, Function1<Field<ID, Initial>, Field<ID, Initial>>): Field<ID, Initial>
  + repeat(Initial, Function1<Initial, Initial>): Initial
  + exchanging(Initial, Function2<YieldingContext<Field<ID, Initial>, Field<ID, Return>>, Field<ID, Initial>, YieldingResult<Field<ID, Initial>, Field<ID, Return>>>): Field<ID, Return>
  + repeating(Initial, Function2<YieldingContext<Initial, Return>, Initial, YieldingResult<Initial, Return>>): Return
  + alignedOn(Object?, Function0<R>): R
   localId: ID
}

class AggregateContext<ID> {
  + newState(): Map<Path, Object>
  + messagesToSend(): OutboundMessage<ID>
}

class AggregateResult<ID, R> {
   toSend: OutboundMessage<ID>
   newState: Map<Path, Object>
   result: R
   localId: ID
}

class Collektive<ID, R> {
  + cycle(): R
  + cycleWhile(Function1<AggregateResult<ID, R>, Boolean>): R
   state: Map<Path, Object>
   localId: ID
}

class Companion {
  + aggregate(ID, Iterable<InboundMessage<ID>>, Map<Path, Object>, Function1<Aggregate<ID>, R>): AggregateResult<ID, R>
  + aggregate(ID, Network<ID>, Map<Path, Object>, Function1<Aggregate<ID>, R>): AggregateResult<ID, R>
}

interface Stack << interface >> {
  + dealign(): Unit
  + alignRaw(Object?): Unit
  + currentPath(): Path
}

interface Path << interface >> {
  + tokens(): List<Object>
}

interface Field<ID, T> << interface >> {
   neighborsCount: Int
   localValue: T
   localId: ID
}

interface Network<ID> << interface >> {
  + read(): Collection<InboundMessage<ID>>
  + write(OutboundMessage<ID>): Unit
}

Companion  +--  Collektive
Aggregate <|-- AggregateContext
AggregateResult <.. Companion
Field <.. Aggregate
Aggregate <.. Collektive
Network <.. Collektive
Path <.. Stack
Stack <.. AggregateContext
@enduml